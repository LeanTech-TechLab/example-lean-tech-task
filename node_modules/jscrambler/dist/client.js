'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _lodash = require('lodash.defaults');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _lodash3 = require('lodash.keys');

var _lodash4 = _interopRequireDefault(_lodash3);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _httpsProxyAgent = require('@jscrambler/https-proxy-agent');

var _httpsProxyAgent2 = _interopRequireDefault(_httpsProxyAgent);

var _httpProxyAgent = require('http-proxy-agent');

var _httpProxyAgent2 = _interopRequireDefault(_httpProxyAgent);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _generateSignedParams = require('./generate-signed-params');

var _generateSignedParams2 = _interopRequireDefault(_generateSignedParams);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = !!process.env.DEBUG;

var ClientError = function (_Error) {
  _inherits(ClientError, _Error);

  function ClientError(message, statusCode) {
    _classCallCheck(this, ClientError);

    var _this = _possibleConstructorReturn(this, (ClientError.__proto__ || Object.getPrototypeOf(ClientError)).call(this, message));

    _this.statusCode = statusCode;
    return _this;
  }

  return ClientError;
}(Error);

/**
 * @class JScramblerClient
 * @param {Object} options
 * @param {String} options.accessKey
 * @param {String} options.secretKey
 * @param {String} [options.host=api.jscrambler.com]
 * @param {String} [options.port=443]
 * @param {String} [options.basePath]
 * @param {String} [options.clientId=0]
 * @author José Magalhães (magalhas@gmail.com)
 * @license MIT <http://opensource.org/licenses/MIT>
 */

function JScramblerClient(options) {
  // Sluggish hack for backwards compatibility
  if (options && !options.keys && (options.accessKey || options.secretKey)) {
    options.keys = {};
    options.keys.accessKey = options.accessKey;
    options.keys.secretKey = options.secretKey;
  }

  options.keys = (0, _lodash2.default)(options.keys || {}, _config2.default.keys);

  /**
   * @member
   */
  this.options = (0, _lodash2.default)(options || {}, _config2.default);

  var _options = this.options,
      jscramblerVersion = _options.jscramblerVersion,
      clientId = _options.clientId;


  this.axiosInstance = _axios2.default.create({
    headers: {
      jscramblerVersion: jscramblerVersion,
      clientId: clientId
    },
    maxBodyLength: 100 * 1000 * 1000 // 100 MB
  });
}
/**
 * Delete request.
 * @param {String} path
 * @param {Object} params
 * @param {Callback} callback
 */
JScramblerClient.prototype.delete = function (path, params) {
  return this.request('DELETE', path, params);
};
/**
 * Get request.
 * @param {String} path
 * @param {Object} params
 * @param {Callback} callback
 */
JScramblerClient.prototype.get = function (path, params) {
  var isJSON = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  return this.request('GET', path, params, isJSON);
};
/**
 * HTTP request.
 * @param {String} method
 * @param {String} path
 * @param {Object} params
 * @param {Callback} callback
 */
JScramblerClient.prototype.request = function (method, path) {
  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var isJSON = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var signedData = void 0;
  if (this.options.useHeaderAuth) {
    if (!this.token) {
      throw new Error('Generating auth token when useHeaderAuth === true is not yet supported. You need to set the jscramblerClient token property explicitly.');
    }
  } else {
    if (this.token) {
      params.token = this.token;
    } else {
      if (!this.options.keys.accessKey) {
        throw new Error('Required *accessKey* not provided');
      }

      if (!this.options.keys.secretKey) {
        throw new Error('Required *secretKey* not provided');
      }
    }
  }

  var _keys = (0, _lodash4.default)(params);
  for (var i = 0, l = _keys.length; i < l; i++) {
    if (params[_keys[i]] instanceof Array) {
      params[_keys[i]] = params[_keys[i]].join(',');
    }
  }

  // If post sign data and set the request as multipart
  if (this.options.keys.accessKey && this.options.keys.secretKey) {
    signedData = (0, _generateSignedParams2.default)(method, path, this.options.host, this.options.keys, params, this.options.utc);
  } else {
    signedData = params;
  }

  var _options2 = this.options,
      protocol = _options2.protocol,
      port = _options2.port,
      proxy = _options2.proxy;


  if (!port && !protocol) {
    port = 443;
    protocol = 'https';
  }

  if (!port) {
    port = protocol === 'https' ? 443 : 80;
  }

  if (!protocol) {
    protocol = port === 443 ? 'https' : 'http';
  }

  var formattedUrl = _url2.default.format({
    hostname: this.options.host,
    port: port,
    pathname: this.options.basePath + path,
    protocol: protocol
  });

  var data = void 0;
  var settings = {};

  // Internal CA
  var agentOptions = {};
  if (this.options.cafile) {
    agentOptions = {
      ca: _fs2.default.readFileSync(this.options.cafile)
    };
  }

  if (proxy || (typeof proxy === 'undefined' ? 'undefined' : _typeof(proxy)) === 'object') {
    var host = proxy.host,
        _proxy$port = proxy.port,
        _port = _proxy$port === undefined ? 8080 : _proxy$port,
        auth = proxy.auth;

    if (!host) {
      throw new Error('Required *proxy.host* not provided');
    }

    var formattedAuth = undefined;
    if (auth) {
      var username = auth.username,
          password = auth.password;


      if (!username || !password) {
        throw new Error('Required *proxy.auth* username or/and password not provided');
      }

      formattedAuth = username + ':' + password;
    }

    /**
     * Monkey-patch to inject a custom Cert CA into TLS.connect
     * options.
     */
    if (agentOptions.ca) {
      var oriCallback = _httpsProxyAgent2.default.prototype.callback;
      _httpsProxyAgent2.default.prototype.callback = function (req, opts) {
        return oriCallback.call(this, req, Object.assign({}, opts, agentOptions));
      };
    }

    settings.proxy = false;
    var proxyConfig = Object.assign({ host: host, port: _port, auth: formattedAuth }, agentOptions);
    settings.httpsAgent = new _httpsProxyAgent2.default(proxyConfig);
    settings.httpAgent = new _httpProxyAgent2.default(proxyConfig);
  } else if (agentOptions) {
    settings.httpsAgent = new _https2.default.Agent(agentOptions);
    settings.httpAgent = new _http2.default.Agent(agentOptions);
  }

  if (!isJSON) {
    settings.responseType = 'arraybuffer';
  }

  var promise = void 0;

  if (method === 'GET' || method === 'DELETE') {
    settings.params = signedData;
    promise = this.axiosInstance[method.toLowerCase()](formattedUrl, settings);
  } else {
    data = signedData;
    promise = this.axiosInstance[method.toLowerCase()](formattedUrl, data, settings);
  }

  return promise.then(function (res) {
    return res.data;
  }).catch(function (err) {
    var errorMessage = 'Unexpected Response: ';
    var statusCode = 500;

    if (err.response) {
      if (debug) {
        console.error(err.response);
      }

      errorMessage += err.response.status + ' ' + err.response.statusText;
      statusCode = err.response.status;

      // For when we have API error messages
      if (err.response.data && err.response.data.error && err.response.data.message) {
        errorMessage += ' - ' + err.response.data.message;
      } else if (err.response.data && err.response.data.errors && err.response.data.errors.length > 0) {
        errorMessage += ' - ' + err.response.data.errors;
      }
    } else {
      errorMessage += err.message;
    }

    throw new ClientError(errorMessage, statusCode);
  });
};
/**
 * Post request.
 * @param {String} path
 * @param {Object} params
 * @param {Callback} callback
 */
JScramblerClient.prototype.post = function (path, params) {
  return this.request('POST', path, params);
};
/**
 * Patch request.
 * @param {string} path
 * @param {object} params
 */
JScramblerClient.prototype.patch = function (path, params) {
  return this.request('PATCH', path, params);
};

var _token = void 0;

Object.defineProperty(JScramblerClient.prototype, 'token', {
  get: function get() {
    return _token;
  },
  set: function set(value) {
    _token = value;
    if (value) {
      if (this.options.useHeaderAuth) {
        this.axiosInstance.defaults.headers['x-user-authentication'] = _token;
      }
    } else {
      delete this.axiosInstance.defaults.headers['x-user-authentication'];
    }
  }
});

exports = module.exports = JScramblerClient;