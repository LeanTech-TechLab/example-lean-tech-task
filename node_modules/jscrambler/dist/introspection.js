'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intoObjectType = exports.query = exports.mutation = exports.type = undefined;

var type = exports.type = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(client, name) {
    var jscramblerVersion, query, res, __type;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            jscramblerVersion = client.options.jscramblerVersion;


            if (!typeCache[jscramblerVersion]) {
              typeCache[jscramblerVersion] = {};
            }

            if (!typeCache[jscramblerVersion][name]) {
              _context.next = 4;
              break;
            }

            return _context.abrupt('return', typeCache[jscramblerVersion][name]);

          case 4:
            query = {
              query: '\nquery getType($name: String!) {\n  __type(name: $name) {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n}\n\nfragment InputValue on __InputValue {\n  name\n  description\n  type { ...TypeRef }\n  defaultValue\n}\n\nfragment TypeRef on __Type {\n  kind\n  name\n  inputFields {\n    name\n    type {\n      name\n      kind\n    }\n  }\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n      }\n    }\n  }\n}',
              params: JSON.stringify({
                name: name
              })
            };
            _context.next = 7;
            return client.get('/application', query);

          case 7:
            res = _context.sent;
            __type = res.data.__type;


            typeCache[jscramblerVersion][__type.name] = __type;

            return _context.abrupt('return', __type);

          case 11:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function type(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var mutation = exports.mutation = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(client, name) {
    var rootMutation, mutationType;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return type(client, 'RootMutation');

          case 2:
            rootMutation = _context2.sent;
            mutationType = rootMutation.fields.find(function (f) {
              return f.name === name;
            });
            return _context2.abrupt('return', mutationType);

          case 5:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function mutation(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();

var query = exports.query = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(client, name) {
    var rootQuery, queryType;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return type(client, 'RootQuery');

          case 2:
            rootQuery = _context3.sent;
            queryType = rootQuery.fields.find(function (f) {
              return f.name === name;
            });
            return _context3.abrupt('return', queryType);

          case 5:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function query(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
}();

var intoObjectType = exports.intoObjectType = function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(client, obj, name) {
    var _this = this;

    var fields, finalObj, keys;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return type(client, name);

          case 2:
            fields = _context5.sent.fields;
            finalObj = {};
            keys = Object.keys(obj);
            _context5.next = 7;
            return Promise.all(keys.map(function () {
              var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(k) {
                var field;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        field = fields.find(function (f) {
                          return f.name === k;
                        });

                        if (!(field && field.type)) {
                          _context4.next = 14;
                          break;
                        }

                        finalObj[k] = (0, _lodash2.default)(obj[k]);

                        if (!(field.type.kind === 'OBJECT' && !!field.type.name)) {
                          _context4.next = 8;
                          break;
                        }

                        _context4.next = 6;
                        return intoObjectType(client, finalObj[k], field.type.name);

                      case 6:
                        finalObj[k] = _context4.sent;
                        return _context4.abrupt('return');

                      case 8:
                        if (!((field.type.kind === 'NON_NULL' || field.type.kind === 'LIST') && field.type.ofType.kind === 'OBJECT')) {
                          _context4.next = 13;
                          break;
                        }

                        _context4.next = 11;
                        return intoObjectType(client, finalObj[k], field.type.ofType.name);

                      case 11:
                        finalObj[k] = _context4.sent;
                        return _context4.abrupt('return');

                      case 13:

                        if (field.type.name === 'String' && typeof finalObj[k] !== 'string') {
                          finalObj[k] = JSON.stringify(finalObj[k]);
                        }

                      case 14:
                      case 'end':
                        return _context4.stop();
                    }
                  }
                }, _callee4, _this);
              }));

              return function (_x10) {
                return _ref5.apply(this, arguments);
              };
            }()));

          case 7:
            return _context5.abrupt('return', finalObj);

          case 8:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));

  return function intoObjectType(_x7, _x8, _x9) {
    return _ref4.apply(this, arguments);
  };
}();

var _lodash = require('lodash.clonedeep');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var typeCache = {};