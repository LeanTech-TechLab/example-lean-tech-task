'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unzip = exports.zip = exports.outputFileSync = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var zip = exports.zip = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(files, cwd) {
    var deferred, hasFiles, _zip, zipFile, _zip2, i, l, buffer, name, sPath, tempFile;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            debug && console.log('Zipping files', (0, _util.inspect)(files));
            deferred = (0, _q.defer)();
            // Flag to detect if any file was added to the zip archive

            hasFiles = false;
            // Sanitize `cwd`

            if (cwd) {
              cwd = (0, _path2.normalize)(cwd);
            }
            // If it's already a zip file

            if (!(files.length === 1 && /^.*\.zip$/.test(files[0]))) {
              _context.next = 15;
              break;
            }

            hasFiles = true;
            _zip = new _jszip2.default();
            zipFile = (0, _fsExtra.readFileSync)(files[0]);


            (0, _fsExtra.outputFileSync)(_temp2.default.openSync({ suffix: '.zip' }).path, zipFile);
            _context.next = 11;
            return _zip.loadAsync(zipFile);

          case 11:
            zipFile = _context.sent;

            deferred.resolve(zipFile);
            _context.next = 43;
            break;

          case 15:
            _zip2 = new _jszip2.default();
            i = 0, l = files.length;

          case 17:
            if (!(i < l)) {
              _context.next = 29;
              break;
            }

            // Sanitise path
            if (typeof files[i] === 'string') {
              files[i] = (0, _path2.normalize)(files[i]);
              if (files[i].indexOf('../') === 0) {
                files[i] = (0, _path2.resolve)(files[i]);
              }
            }
            // Bypass unwanted patterns from `files`

            if (!/.*\.(git|hg)(\/.*|$)/.test(files[i].path || files[i])) {
              _context.next = 21;
              break;
            }

            return _context.abrupt('continue', 26);

          case 21:
            buffer = void 0, name = void 0;
            sPath = void 0;

            if (cwd && files[i].indexOf && files[i].indexOf(cwd) !== 0) {
              sPath = (0, _path2.join)(cwd, files[i]);
            } else {
              sPath = files[i];
            }
            // If buffer
            if (files[i].contents) {
              name = (0, _path2.relative)(files[i].cwd, files[i].path);
              buffer = files[i].contents;
            } else if (!(0, _fsExtra.statSync)(sPath).isDirectory()) {
              // Else if it's a path and not a directory
              if (cwd && files[i].indexOf && files[i].indexOf(cwd) === 0) {
                name = files[i].substring(cwd.length);
              } else {
                name = files[i];
              }
              buffer = (0, _fsExtra.readFileSync)(sPath);
            } else {
              // Else if it's a directory path
              _zip2.folder(sPath);
            }
            if (name) {
              hasFiles = true;
              _zip2.file(name, buffer);
            }

          case 26:
            ++i;
            _context.next = 17;
            break;

          case 29:
            if (!hasFiles) {
              _context.next = 42;
              break;
            }

            tempFile = _temp2.default.openSync({ suffix: '.zip' });
            _context.t0 = _fsExtra.outputFileSync;
            _context.t1 = tempFile.path;
            _context.next = 35;
            return _zip2.generateAsync({ type: 'nodebuffer' });

          case 35:
            _context.t2 = _context.sent;
            (0, _context.t0)(_context.t1, _context.t2);

            files[0] = tempFile.path;
            files.length = 1;
            deferred.resolve(_zip2);
            _context.next = 43;
            break;

          case 42:
            throw new Error('No source files found. If you intend to send a whole directory sufix your path with "**" (e.g. ./my-directory/**)');

          case 43:
            return _context.abrupt('return', deferred.promise);

          case 44:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function zip(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var unzip = exports.unzip = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(zipFile, dest) {
    var stream = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var zip, _size, results, file, buffer, destPath, lastDestChar, _file;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            zip = new _jszip2.default();
            _context2.next = 3;
            return zip.loadAsync(zipFile);

          case 3:
            _size = (0, _lodash2.default)(zip.files);
            results = [];
            _context2.t0 = regeneratorRuntime.keys(zip.files);

          case 6:
            if ((_context2.t1 = _context2.t0()).done) {
              _context2.next = 15;
              break;
            }

            file = _context2.t1.value;

            if (zip.files[file].dir) {
              _context2.next = 13;
              break;
            }

            _context2.next = 11;
            return zip.file(file).async('nodebuffer');

          case 11:
            buffer = _context2.sent;


            if (typeof dest === 'function') {
              if (stream) {
                dest(buffer, file);
              } else {
                results.push({ filename: file, content: buffer.toString() });
              }
            } else if (dest && typeof dest === 'string') {
              lastDestChar = dest[dest.length - 1];

              if (_size === 1 && lastDestChar !== '/' && lastDestChar !== '\\') {
                destPath = dest;
              } else {
                _file = file;
                // Deal with win path join c:\dest\:c\src

                if (isWinAbsolutePath(_file)) {
                  _file = parseWinAbsolutePath(_file).path;
                }
                destPath = (0, _path2.join)(dest, _file);
              }
              (0, _fsExtra.outputFileSync)(destPath, buffer);
            }

          case 13:
            _context2.next = 6;
            break;

          case 15:

            if (!stream) {
              dest(results);
            }

          case 16:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function unzip(_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();

exports.zipSources = zipSources;

var _lodash = require('lodash.size');

var _lodash2 = _interopRequireDefault(_lodash);

var _temp = require('temp');

var _temp2 = _interopRequireDefault(_temp);

var _jszip = require('jszip');

var _jszip2 = _interopRequireDefault(_jszip);

var _fsExtra = require('fs-extra');

var _path2 = require('path');

var _q = require('q');

var _util = require('util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } // TODO Replace `sync` functions with async versions

var debug = !!process.env.DEBUG;

// ./zip.js module is excluded from browser-like environments. We take advantage of that here.
exports.outputFileSync = _fsExtra.outputFileSync;
function zipSources(sources) {
  var zipFile = new _jszip2.default();
  var fileNames = sources.map(function (source) {
    zipFile.file(source.filename, source.content);
    return source.filename;
  });

  if (debug) {
    console.log('Zipping files', (0, _util.inspect)(fileNames));
  }
  return Promise.resolve(zipFile);
}

function isWinAbsolutePath(path) {
  return (0, _path2.isAbsolute)(path) && /^([a-z]:)(.*)/i.test(path);
}

function parseWinAbsolutePath(_path) {
  var _path$match = _path.match(/^([a-z]:)(.*)/i),
      _path$match2 = _slicedToArray(_path$match, 3),
      full = _path$match2[0],
      drv = _path$match2[1],
      path = _path$match2[2];

  return {
    drv: drv,
    path: path
  };
}